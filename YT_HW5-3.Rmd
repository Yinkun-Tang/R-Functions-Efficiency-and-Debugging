---
title: "Homework 5"
author: "Yinkun Tang"
date: "2023-06-11"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("D:/Yinkun/UC Davis - Yinkun Tang/Third Academic Year/Spring Quarter 2023/STA 141B/HW5F")
```

```{r echo=FALSE}
library(readr)
FileString = read_file("D:/Yinkun/UC Davis - Yinkun Tang/Third Academic Year/Spring Quarter 2023/STA 141B/HW5F/PercentEncodedString.txt")
```

The Conversion Functions and the Running Time Functions are already prepared in external R Script File. Use "source" function to load all necessary functions.
```{r}
source("Functions.R")
```

In order to generate strings used for evaluation of different approaches' running time, we mix up normal letters with special characters starting with "%" from the encoding table.
```{r}
LettersVec = letters
UpperLettersVec = LETTERS
SpecialCharacters = c("%21", "%23", "%24", "%26", "%30", "%31", "%32", "%33", "%34", "%35", "%36", "%37", "%38", "%39", "%40", "%41", "%42", "%43", "%44", "%45", "%46", "%47", "%48", "%49", "%4A", "%4B", "%4C", "%4D", "%4E", "%4F", "%50", "%51", "%52", "%53", "%54", "%55", "%56", "%57", "%58", "%59", "%5A", "%61", "%62", "%63", "%64", "%65", "%66", "%67", "%68", "%69", "%6A", "%6B", "%6C", "%6D", "%6E", "%6F", "%70", "%71", "%72", "%73", "%74", "%75", "%76", "%77", "%78", "%79", "%7A")
CombinationVec = c(LettersVec, UpperLettersVec, SpecialCharacters)
```

Then, we generate the strings used for testing and check the length of all strings.
```{r eval=FALSE}
Str_1 <- paste0(sample(CombinationVec, size = 1, replace = TRUE), collapse = "")
Str_10 <- paste0(sample(CombinationVec, size = 10, replace = TRUE), collapse = "")
Str_100 <- paste0(sample(CombinationVec, size = 100, replace = TRUE), collapse = "")
Str_1000 <- paste0(sample(CombinationVec, size = 1000, replace = TRUE), collapse = "")
Str_10000 <- paste0(sample(CombinationVec, size = 10000, replace = TRUE), collapse = "")
Str_100000 <- paste0(sample(CombinationVec, size = 100000, replace = TRUE), collapse = "")
Str_200000 <- paste0(sample(CombinationVec, size = 200000, replace = TRUE), collapse = "")
Str_225000 <- paste0(sample(CombinationVec, size = 225000, replace = TRUE), collapse = "")
Str_250000 <- paste0(sample(CombinationVec, size = 250000, replace = TRUE), collapse = "")
```

```{r eval=FALSE}
LengthVec = c(nchar(Str_1), nchar(Str_10), nchar(Str_100), nchar(Str_1000), nchar(Str_10000), nchar(Str_100000), nchar(Str_200000), nchar(Str_225000), nchar(Str_250000))
```

```{r echo=FALSE}
LengthVec = readRDS("LengthVec.rds")
```

# Running Test For Original Function

Using the pre-defined functions, we start with running the running time calculation functions regarding the original utils::URLDecode function.
```{r eval=FALSE}
time_origin_1 = OriginalRunningTime(Str = Str_1)
time_origin_10 = OriginalRunningTime(Str = Str_10)
time_origin_100 = OriginalRunningTime(Str = Str_100)
time_origin_1000 = OriginalRunningTime(Str = Str_1000)
time_origin_10000 = OriginalRunningTime(Str = Str_10000)
time_origin_100000 = OriginalRunningTime(Str = Str_100000)
time_origin_200000 = OriginalRunningTime(Str = Str_200000)
time_origin_225000 = OriginalRunningTime(Str = Str_225000)
time_origin_250000 = OriginalRunningTime(Str = Str_250000)
```

Since unit used in this assignment should be seconds, thus some adjustments are needed for the running time calculation regarding the provided full string.
```{r eval=FALSE}
time_origin_File = OriginalRunningTime(Str = FileString) * 60
```

Eventually, a collection of running times is generated for later plot production.
```{r eval=FALSE}
time_origin_vec = c(time_origin_1, time_origin_10, time_origin_100, time_origin_1000, time_origin_10000, time_origin_100000, time_origin_200000, time_origin_225000, time_origin_250000)
```

```{r echo=FALSE}
time_origin_vec = readRDS("TimeOriginVector.rds")
time_origin_File = readRDS("FileStrTimeOrigin.rds")
```

Besides, we also generate the converted string of the given full string, which could be used for the demonstration of the correctness of other self-defined functions.

```{r eval=FALSE}
DecodeResult = utils::URLdecode(FileString)
```

```{r echo=FALSE}
DecodeResult = readRDS("CorrectStr.rds")
```

# Running Test For Preallocation Function

The correctness of preallocation optimization has been verified in other Rmarkdown File by using logic comparison between the result generated by utils::URLDecode function and the result generated by preallocation optimization. The logic comparison result turns out to be TRUE, which means that the preallocation optimization generates the same result as the utils::URLDecode function.

Consider the following code, which should be able to demonstrate the correctness of the preallocation function:

```{r}
# Generate the converted full string using preallocation method
Preallocation_DecodeResult = Preallocated_URLdecode(FileString)
# Compare the conversion result with the result generated by utils::URLDecode
Preallocation_DecodeResult == DecodeResult
```

With similar procedure, now we start with collecting the running time with preallocation method.
```{r eval=FALSE}
time_pre_1 = PreallocationRunningTime(Str = Str_1)
time_pre_10 = PreallocationRunningTime(Str = Str_10)
time_pre_100 = PreallocationRunningTime(Str = Str_100)
time_pre_1000 = PreallocationRunningTime(Str = Str_1000)
time_pre_10000 = PreallocationRunningTime(Str = Str_10000)
time_pre_100000 = PreallocationRunningTime(Str = Str_100000)
time_pre_200000 = PreallocationRunningTime(Str = Str_200000)
time_pre_225000 = PreallocationRunningTime(Str = Str_225000)
time_pre_250000 = PreallocationRunningTime(Str = Str_250000)
time_pre_File = PreallocationRunningTime(Str = FileString)
```

```{r eval=FALSE}
time_pre_vec = c(time_pre_1, time_pre_10, time_pre_100, time_pre_1000, time_pre_10000, time_pre_100000, time_pre_200000, time_pre_225000, time_pre_250000)
```

```{r echo=FALSE}
time_pre_vec = readRDS("TimePreVector.rds")
time_pre_File = readRDS("FileStrTimePre.rds")
```

# Running Test For Vectorization Function

The correctness of vectorization optimization has been verified in other Rmarkdown File by using logic comparison between the result generated by utils::URLDecode function and the result generated by vectorization optimization. The logic comparison result turns out to be TRUE, which means that the vectorization optimization generates the same result as the utils::URLDecode function.

Consider the following code, which should be able to demonstrate the correctness of the vectorization function:

```{r}
# Generate the converted full string using vectorization method
Vectorization_DecodeResult = Vectorization_URLDecode(FileString)
# Compare the conversion result with the result generated by utils::URLDecode
Vectorization_DecodeResult == DecodeResult
```

With similar procedure, now we start with collecting the running time with vectorization method.
```{r eval=FALSE}
time_vec_1 = VectorizationRunningTime(Str = Str_1)
time_vec_10 = VectorizationRunningTime(Str = Str_10)
time_vec_100 = VectorizationRunningTime(Str = Str_100)
time_vec_1000 = VectorizationRunningTime(Str = Str_1000)
time_vec_10000 = VectorizationRunningTime(Str = Str_10000)
time_vec_100000 = VectorizationRunningTime(Str = Str_100000)
time_vec_200000 = VectorizationRunningTime(Str = Str_200000)
time_vec_225000 = VectorizationRunningTime(Str = Str_225000)
time_vec_250000 = VectorizationRunningTime(Str = Str_250000)
time_vec_File = VectorizationRunningTime(Str = FileString)
```

```{r eval=FALSE}
time_vec_vec = c(time_vec_1, time_vec_10, time_vec_100, time_vec_1000, time_vec_10000, time_vec_100000, time_vec_200000, time_vec_225000, time_vec_250000)
```

```{r echo=FALSE}
time_vec_vec = readRDS("TimeVecVector.rds")
time_vec_File = readRDS("FileStrTimeVec.rds")
```

# Plot Demonstration

With collected datasets, we could now generate the running time plot to view the difference of running time among these approaches.

In the following plots, the blue line stands for the performance of the original utils::URLDecode function, the green line stands for the performance of the preallocation function, the red line stands for the performance of the vectorization function.
```{r}
plot(LengthVec, time_origin_vec, main = "URLDecode Function Performance Comparison", xlab = "Number of Characters", ylab = "Running Time (Seconds)", type = "l", col = "blue")
lines(LengthVec, time_pre_vec, type = "l", col = "green")
lines(LengthVec, time_vec_vec, type = "l", col = "red")
```
Since the performance for preallocation and vectorization are hard to distinguish in the above plot, we need an additional plot for these two methods comparison.
```{r}
plot(LengthVec, time_pre_vec, main = "URLDecode Optimized Function Performance Comparison", xlab = "Number of Characters", ylab = "Running Time (Seconds)", type = "l", col = "green")
lines(LengthVec, time_vec_vec, type = "l", col = "red")
```
Therefore, based on the plot, we could demonstrate that the vectorization method has better performance compared to the preallocation method.

# Full String Decode Running Time

Finally, we record and show the running time needed for all methods to decode the given full string:
```{r echo=FALSE}
print("The running time (seconds) needed for utils::URLDecode to decode the full string is: ")
print(time_origin_File)
print("The running time (seconds) needed for preallocation method to decode the full string is: ")
print(time_pre_File)
print("The running time (seconds) needed for vectorization method to decode the full string is: ")
print(time_vec_File)
```





